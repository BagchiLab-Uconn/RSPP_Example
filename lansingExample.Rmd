---
title: "RSPPlme4 Lansing Example"
author: "Michael LaScaleia"
date: "10/19/2021"
output: html_document
---

```{r setup, echo = F}
# clear environment
rm(list = ls())

# load necessary packages (and dependencies)
library(spatstat)
library(RSPPlme4)
library(tidyverse)

# load dataset 
data <- spatstat.data::lansing

# scale window to be 0 to 100, not 0 to 1
data <- rescale(data, .01)

# because "misc" is not a single tree species, we will not use it in this example
data <- subset(data, marks != "misc", drop = T)

# these data start as an object with class ppp (planar point pattern), which is an easier starting point than most datasets
# so, first, this code will convert that ppp to a dataframe, which is a more standard starting point
df_data <- as.data.frame(data)

# get rid of duplicated points
df_data <- df_data[!duplicated(df_data[, c("x", "y")]),]

```


The `lansing` planar point pattern (ppp) used here is a single, large plot measuring five tree species. The purpose of this analysis is to show how the general point patterns of this large plot can be determined from a replicated spatial point pattern analysis (RSPP). The code below splits the large, single `lansing` plot into a (changeable) number of subplots, then samples a percent of those, depending on the percentage of the large, single plot those subplots cover. By default, we are sampling 15 subplots covering about 60% of the original site.

The code chunk below can generally be ignored if your data are already divided into subplots in your sampling methods.

```{r}
# number of subplots to sample
sampled_SPs <- 12 

# approximate percent of total area to sample
percentArea <- .48

# determine how many subplots total should be created, given the above 2 parameters
sqrtTotalPlots <- sqrt(sampled_SPs/percentArea) %/% 1

# determine the x and y boundaries of the sub-plots
xy <- seq(0, 100, length.out = sqrtTotalPlots + 1)

# create the specific boundaries of the specific subPlots
subPlots <- data.frame(subPlotID = (1:(sqrtTotalPlots)^2), 
                    xmin = rep(xy[-length(xy)], sqrtTotalPlots),
                    ymin = rep(xy[-length(xy)], each = sqrtTotalPlots))

# assign each tree a specific subplot, given their x and y coordinates
df_data$xmin <- df_data$x %/% xy[2] * xy[2]
df_data$ymin <- df_data$y %/% xy[2] * xy[2]
divided_data <- merge(df_data, subPlots, by = c("xmin","ymin"))
divided_data$genx <- (divided_data$x - divided_data$xmin)/ xy[2]
divided_data$geny <- (divided_data$y - divided_data$ymin)/ xy[2]
divided_data$xmin <- NULL
divided_data$ymin <- NULL

# select the specified number of plots randomly (represents sampling)
set.seed(19082021)
sampledSubPlots <- (divided_data[divided_data$subPlotID %in% sample(1:max(divided_data$subPlotID), sampled_SPs),])

```

Here is a side-by-side comparison of the entire `lansing` plot and the `sampledSubPlots`. 

```{r}
par(mfcol = c(1,2))

ggplot(data = df_data, aes(x = x, y = y)) +
  geom_point(aes(shape = marks, color = marks)) +
  theme_bw() 

ggplot(data = sampledSubPlots, aes(x = x, y = y)) +
  geom_point(aes(shape = marks, color = marks)) +
  theme_bw() 
```
While in this example subplots are connected, subplots can also be spatially isolated (as is more common in random sampling of large areas). Code from here can generally be applied to any spatial data that is divided into subplots.

```{r}
# first, set up a hyperframe of the sub-plot IDs and any random effects/grouping variables.
# Here, our only random effect/grouping variable is the tree species, called "marks"
groupedByRandomEffect <- sampledSubPlots %>% 
  group_by(marks, subPlotID) %>%
  summarise()
hf <- as.hyperframe(groupedByRandomEffect)

# next, convert each subplot-random effect combination into its own ppp
# here, we split our large dataframe of all subplots into a list of smaller dataframes
# the splitting parameters are the subPlotID, and any random effects/grouping variables, which again is just "marks"
# make absolutely certain that this split and the hyperframe end up in the same order
splitByRandomEffect <- split(sampledSubPlots, f = list(sampledSubPlots$subPlotID, sampledSubPlots$marks), drop=TRUE)

# now, lapply the function "ppp," which will convert each dataframe in the list to a ppp
# make sure your arguments for window within each ppp are specified properly for your data
# additionally, note that the coordinates in each ppp are the coordinates within each subplot, not the overall coordinates
pppList <- lapply(splitByRandomEffect, function(df){
  return(ppp(x = df$x, df$y, window = owin(x=c(0, 100), y=c(0, 100))))
  })

# since the random effects are listed as a hyperframe, the list of ppps can be appended directly
hf$pppx <- pppList

# remove any plant-subplot ppp that has 3 or fewer points
# analysis is not possible on plots with so few points (4 is minimum)
hf <- hf[sapply(hf$pppx, npoints) > 3,]

length(hf$pppx)
```

With this particular example, we now have 52 unique subplot-tree species combinations. Here is what they look like compared to their undivided version in the `lansing` dataset. Trees that we have "sampled" in our sub-sampling are in black, while unsampled trees are colored.

```{r}
par(mfcol = c(1,2))
paints <- c("orange", "green", "purple", "red", "blue")

lapply(levels(hf$marks), function(t){

  ggplot(data = df_data[df_data$marks %in% t,], aes(x = x, y = y)) +
    geom_point(color = paints[which(t == levels(hf$marks))]) +
    ggtitle(t) +
    geom_point(data = do.call("rbind", lapply(hf$pppx[hf$marks %in% t], as.data.frame)), color = "black") +
    theme_bw()
})

# remove excess variables
rm(pppList, splitByRandomEffect, paints)

```
Now, we can preform our RSPP on the sub-sampled plots


```{r}
# distances at which we will measure (a sequence spanning 1/4 of one edge of the plot)
r <-  0:24

# create the k estimate
hf$k <-  lapply(hf$pppx, Kest, r = r, correction = "border")

# add in weights
hf$wts <- lapply(hf$pppx, kfuncWeightsCalc, r=r,
                  correction="border", type="nx_A")

# remove rows where the weights are 0 (should be none because we removed plots with <3 points)
hf <- hf[!(sapply(hf$wts, function(x) any(x ==0))),]

# run model
mod_sm <- klmer(formula = k ~ 1  + marks + (1|subPlotID),
                     r=r, hyper=hf,  correction='border', weights = 'wts',
                     na.action="na.omit")

# plot models

preddat <- expand.grid(marks = factor(c("blackoak", "hickory", "maple", "redoak", "whiteoak")))
Xmat <- model.matrix(~marks, data=preddat)
mod_sm_cis <- confint(mod_sm, level=0.95, lin_comb=Xmat, nboot=10, ncore=4, iseed=1234)
plot(mod_sm_cis)

# full plot analysis
dd <- df_data %>%
  split(f = df_data$marks,
        drop = T)
fp <- lapply(dd, function(hf) ppp(x=hf$x, y = hf$y, window = owin(x=c(0,100), y=c(0, 100))))
ests <- lapply(fp, envelope)
lapply(ests, plot)

```

Now to do the thinning and the thickening

```{r}
byPlant <- split(data, f = data$marks, drop = T)

thinned_list <- lapply(1:5, function(i){
  pla <- byPlant[[i]]
  mm <- as.matrix(dist(coords(pla)))
  mm[lower.tri(mm)] <- 0
  
  thold <- .04
  keepers <- apply(mm, 1, function(x, told = thold){
    y <- x[x != 0]
    if(length(y) != 0){
      if(min(y) < told)
        keep <- 0
      else
        keep <- 1
    }
    else
      keep <- 1
    return(keep)
  })
  
  tmap <- rthin(pla, P = keepers)
  return(tmap)
})

thinned_ppp <- do.call("superimpose", thinned_list)
thinned_df <- as.data.frame(thinned_ppp)


range01 <- function(x){(x-min(x))/(max(x)-min(x))}
thicked_list <- lapply(1:5, function(i){
  pla <- byPlant[[i]]
  newh <- rpoint(pla$n, f = range01(density(pla)^4))
  newh$marks <- as.factor(rep(unique(pla$marks), newh$n))
  newh$markformat <- "vector"
  hs <- superimpose(pla, newh)
  return(hs)
  }
)

thicked_ppp <- do.call("superimpose", thicked_list)
thicked_df <- as.data.frame(thicked_ppp)

# do the same as (way) above, but with our new dataframes

makeSubplots <- function(dataToSubdivide){
  dataToSubdivide$xmin <- dataToSubdivide$x %/% xy[2] * xy[2]
  dataToSubdivide$ymin <- dataToSubdivide$y %/% xy[2] * xy[2]
  divided_data <- merge(dataToSubdivide, subPlots, by = c("xmin","ymin"))
  divided_data$genx <- (divided_data$x - divided_data$xmin)/ xy[2]
  divided_data$geny <- (divided_data$y - divided_data$ymin)/ xy[2]
  divided_data$xmin <- NULL
  divided_data$ymin <- NULL
  # select the specified number of plots randomly (represents sampling)
  set.seed(19082021)
  sampledSubPlots <- (divided_data[divided_data$subPlotID %in% sample(1:max(divided_data$subPlotID), sampled_SPs),])
  return(sampledSubPlots)
}

thinSubs <- makeSubplots(thinned_df)
thickSubs <- makeSubplots(thicked_df)


# first, set up a hyperframe of the sub-plot IDs and any random effects/grouping variables.
# Here, our only random effect/grouping variable is the tree species, called "marks"
groupedByRandomEffect <- thinSubs %>% 
  group_by(marks, subPlotID) %>%
  summarise()
hf <- as.hyperframe(groupedByRandomEffect)

# next, convert each subplot-random effect combination into its own ppp
# here, we split our large dataframe of all subplots into a list of smaller dataframes
# the splitting parameters are the subPlotID, and any random effects/grouping variables, which again is just "marks"
# make absolutely certain that this split and the hyperframe end up in the same order
splitByRandomEffect <- split(thinSubs, f = list(thinSubs$subPlotID, thinSubs$marks), drop=TRUE)

# now, lapply the function "ppp," which will convert each dataframe in the list to a ppp
# make sure your arguments for window within each ppp are specified properly for your data
# additionally, note that the coordinates in each ppp are the coordinates within each subplot, not the overall coordinates
pppList <- lapply(splitByRandomEffect, function(df){
  return(ppp(x = df$x, df$y, window = owin(x=c(0, 100), y=c(0, 100))))
  })

# since the random effects are listed as a hyperframe, the list of ppps can be appended directly
hf$pppx <- pppList

# remove any plant-subplot ppp that has 3 or fewer points
# analysis is not possible on plots with so few points (4 is minimum)
hf <- hf[sapply(hf$pppx, npoints) > 3,]

length(hf$pppx)

# create the k estimate
hf$k <-  lapply(hf$pppx, Kest, r = r, correction = "border")

# add in weights
hf$wts <- lapply(hf$pppx, kfuncWeightsCalc, r=r,
                  correction="border", type="nx_A")

# remove rows where the weights are 0 (should be none because we removed plots with <3 points)
hf <- hf[!(sapply(hf$wts, function(x) any(x ==0))),]

# run model
mod_thin <- klmer(formula = k ~ 1  + marks + (1|subPlotID),
                     r=r, hyper=hf,  correction='border', weights = 'wts',
                     na.action="na.omit")

# plot models

preddat <- expand.grid(marks = factor(c("blackoak", "hickory", "maple", "redoak", "whiteoak")))
Xmat <- model.matrix(~marks, data=preddat)
mod_thin_cis <- confint(mod_thin, level=0.95, lin_comb=Xmat, nboot=10, ncore=4, iseed=1234)
plot(mod_thin_cis)


# full plot analysis
dd <- thinned_df %>%
  split(f = df_data$marks,
        drop = T)
fp <- lapply(dd, function(hf) ppp(x=hf$x, y = hf$y, window = owin(x=c(0,100), y=c(0, 100))))
ests <- lapply(fp, envelope)
lapply(ests, plot)


# first, set up a hyperframe of the sub-plot IDs and any random effects/grouping variables.
# Here, our only random effect/grouping variable is the tree species, called "marks"
groupedByRandomEffect <- thickSubs %>% 
  group_by(marks, subPlotID) %>%
  summarise()
hf <- as.hyperframe(groupedByRandomEffect)

# next, convert each subplot-random effect combination into its own ppp
# here, we split our large dataframe of all subplots into a list of smaller dataframes
# the splitting parameters are the subPlotID, and any random effects/grouping variables, which again is just "marks"
# make absolutely certain that this split and the hyperframe end up in the same order
splitByRandomEffect <- split(thickSubs, f = list(thickSubs$subPlotID, thickSubs$marks), drop=TRUE)

# now, lapply the function "ppp," which will convert each dataframe in the list to a ppp
# make sure your arguments for window withick each ppp are specified properly for your data
# additionally, note that the coordinates in each ppp are the coordinates withick each subplot, not the overall coordinates
pppList <- lapply(splitByRandomEffect, function(df){
  return(ppp(x = df$x, df$y, window = owin(x=c(0, 100), y=c(0, 100))))
  })

# since the random effects are listed as a hyperframe, the list of ppps can be appended directly
hf$pppx <- pppList

# remove any plant-subplot ppp that has 3 or fewer points
# analysis is not possible on plots with so few points (4 is minimum)
hf <- hf[sapply(hf$pppx, npoints) > 3,]

length(hf$pppx)

# create the k estimate
hf$k <-  lapply(hf$pppx, Kest, r = r, correction = "border")

# add in weights
hf$wts <- lapply(hf$pppx, kfuncWeightsCalc, r=r,
                  correction="border", type="nx_A")

# remove rows where the weights are 0 (should be none because we removed plots with <3 points)
hf <- hf[!(sapply(hf$wts, function(x) any(x ==0))),]

# run model
mod_thick <- klmer(formula = k ~ 1  + marks + (1|subPlotID),
                     r=r, hyper=hf,  correction='border', weights = 'wts',
                     na.action="na.omit")

# plot models

preddat <- expand.grid(marks = factor(c("blackoak", "hickory", "maple", "redoak", "whiteoak")))
Xmat <- model.matrix(~marks, data=preddat)
mod_thick_cis <- confint(mod_thick, level=0.95, lin_comb=Xmat, nboot=10, ncore=4, iseed=1234)
plot(mod_thick_cis)






```
























